use crate::{
    protocol::{JobConfig, VM},
    resource_manager::{ResourceGuard, ResourceManager},
    vm::Vm as VmTrait,
    vsock,
};
use eyre::{Result, WrapErr};
use libc;
use serde::Deserialize;
use serde_json;
use std::os::{fd::FromRawFd, unix::net::UnixStream as StdUnixStream};
use std::path::PathBuf;
use std::sync::Arc;
use tokio::net::UnixStream;
use tokio::sync::{Mutex, Notify, mpsc};
use tracing::{debug, error, info, warn};
use uuid::Uuid;

use block2::StackBlock;
use objc2::rc::Retained;
use objc2::runtime::ProtocolObject;
use objc2::{AllocAnyThread, DefinedClass, Message, msg_send};

use dispatch2::{DispatchQueue, DispatchQueueAttr, DispatchRetained};
use objc2_foundation::{
    NSArray, NSData, NSDataBase64DecodingOptions, NSError, NSObject, NSObjectProtocol, NSString,
    NSURL,
};
use objc2_virtualization::{
    VZDiskImageCachingMode, VZDiskImageStorageDeviceAttachment, VZDiskImageSynchronizationMode,
    VZMACAddress, VZMacAuxiliaryStorage, VZMacGraphicsDeviceConfiguration,
    VZMacGraphicsDisplayConfiguration, VZMacHardwareModel, VZMacKeyboardConfiguration,
    VZMacMachineIdentifier, VZMacOSBootLoader, VZMacPlatformConfiguration,
    VZMacTrackpadConfiguration, VZNATNetworkDeviceAttachment, VZVirtioBlockDeviceConfiguration,
    VZVirtioEntropyDeviceConfiguration, VZVirtioNetworkDeviceConfiguration,
    VZVirtioSocketConnection, VZVirtioSocketDevice, VZVirtioSocketDeviceConfiguration,
    VZVirtioSocketListener, VZVirtioSocketListenerDelegate,
    VZVirtioTraditionalMemoryBalloonDeviceConfiguration, VZVirtualMachine,
    VZVirtualMachineConfiguration, VZVirtualMachineState,
};
use std::marker::PhantomData;

pub struct QueueBound<T> {
    inner: T,
    pub queue: DispatchRetained<DispatchQueue>,
    _marker: PhantomData<*const ()>,
}

unsafe impl<T> Send for QueueBound<T> {}
unsafe impl<T> Sync for QueueBound<T> {}

impl<T> QueueBound<T> {
    pub fn new(inner: T, queue: DispatchRetained<DispatchQueue>) -> Self {
        Self {
            inner,
            queue,
            _marker: PhantomData,
        }
    }

    pub fn run_sync<F, R>(&self, f: F) -> R
    where
        F: FnOnce(&T) -> R + Send,
        R: Send,
    {
        let mut result = None;
        self.queue.exec_sync(|| {
            result = Some(f(&self.inner));
        });
        result.unwrap()
    }
}

/// Display configuration for a macOS VM
#[derive(Debug, Deserialize)]
#[allow(dead_code)]
struct DisplayConfig {
    /// Width of display in pixels
    width: u32,
    /// Height of display in pixels
    height: u32,
}

/// VM configuration generated by the VM creation tooling.
#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
#[allow(dead_code)]
struct VmImageConfig {
    /// Version of the configuration format
    version: u32,
    /// Architecture of the VM
    arch: String,
    /// Operating system of the VM
    os: String,
    /// Number of CPU cores for the VM
    cpu_count: u32,
    /// Minimum number of CPU cores required
    cpu_count_min: u32,
    /// Size of memory in bytes
    memory_size: u64,
    /// Minimum size of memory in bytes
    memory_size_min: u64,
    /// ECID (Unique Chip ID) in base64
    ecid: String,
    /// Hardware model in base64
    hardware_model: String,
    /// MAC address of the network interface
    mac_address: String,
    /// Display configuration
    display: DisplayConfig,
}

impl VmImageConfig {
    /// Parse configuration from a file
    fn from_file(path: &PathBuf) -> Result<Self> {
        let content = std::fs::read_to_string(path)
            .wrap_err_with(|| format!("Failed to read config file: {}", path.display()))?;

        serde_json::from_str(&content)
            .wrap_err_with(|| format!("Failed to parse config JSON from {}", path.display()))
    }
}

struct ConnectionInfo {
    stream: StdUnixStream,
    #[allow(dead_code)]
    destination_port: u32,
    source_port: u32,
    #[allow(dead_code)]
    job_id: Uuid,
}

struct VSockListenerState {
    connection_notifier: std::sync::Mutex<Option<tokio::sync::mpsc::Sender<ConnectionInfo>>>,
    job_id: uuid::Uuid,
}

objc2::define_class!(
    #[unsafe(super = NSObject)]
    #[name = "VsockListenerDelegate"]
    #[ivars = VSockListenerState]
    struct VsockListenerDelegate;

    unsafe impl NSObjectProtocol for VsockListenerDelegate {}

    unsafe impl VZVirtioSocketListenerDelegate for VsockListenerDelegate {
        // Delegate method called when a client connects to the vsock device
        #[unsafe(method(listener:shouldAcceptNewConnection:fromSocketDevice:))]
        fn should_accept_connection(
            &self,
            _listener: &VZVirtioSocketListener,
            connection: &VZVirtioSocketConnection,
            _socket_device: &VZVirtioSocketDevice,
        ) -> bool {
            let destination_port = unsafe { connection.destinationPort() };
            let source_port = unsafe { connection.sourcePort() };

            info!(
                "VsockListenerDelegate::should_accept_connection called! destination_port: {}, source_port: {}",
                destination_port, source_port
            );

            // Get the notifier
            let notifier_ref = self.ivars().connection_notifier.lock().unwrap();
            let notifier = match notifier_ref.as_ref() {
                Some(n) => n.clone(),
                None => {
                    warn!("No connection notifier available");
                    return false.into();
                }
            };
            drop(notifier_ref);

            // Retain the connection to ensure it stays alive
            let retained_connection = connection.retain();

            // Get the file descriptor from the connection
            let fd = unsafe { retained_connection.fileDescriptor() };

            let dup_fd = unsafe {
                // Duplicate the file descriptor.
                let dup_fd = libc::dup(fd);
                if dup_fd == -1 {
                    warn!(
                        "Failed to duplicate file descriptor: {}",
                        std::io::Error::last_os_error()
                    );
                    return false.into();
                }

                // TODO(sander): test whether the following is necessary
                // Set socket to blocking mode (ensure it's not non-blocking)
                let flags = libc::fcntl(dup_fd, libc::F_GETFL, 0);
                if flags != -1 {
                    libc::fcntl(dup_fd, libc::F_SETFL, flags & !libc::O_NONBLOCK);
                }
                // Set socket options to keep the connection alive
                let keepalive: libc::c_int = 1;
                let result = libc::setsockopt(
                    dup_fd,
                    libc::SOL_SOCKET,
                    libc::SO_KEEPALIVE,
                    &keepalive as *const _ as *const libc::c_void,
                    std::mem::size_of::<libc::c_int>() as libc::socklen_t,
                );
                if result != 0 {
                    warn!(
                        "Failed to set SO_KEEPALIVE: {}",
                        std::io::Error::last_os_error()
                    );
                }

                dup_fd
            };

            // Convert the file descriptor to a std UnixStream
            // We don't convert to tokio here because we're not in a tokio runtime context
            let stream = unsafe { StdUnixStream::from_raw_fd(dup_fd) };

            // Keep it in blocking mode for now - we'll set non-blocking when converting to tokio
            // This avoids issues with the dispatch queue context

            // Create connection info with both FD and source port
            let conn_info = ConnectionInfo {
                stream,
                destination_port,
                source_port,
                job_id: self.ivars().job_id,
            };

            // Send the connection info through the channel
            let job_id = self.ivars().job_id;
            info!(
                "Sending connection info for job {} (fd: {}, source port: {})",
                job_id, fd, source_port
            );

            match notifier.try_send(conn_info) {
                Ok(_) => {
                    info!("Connection info sent successfully");
                    true
                }
                Err(e) => {
                    warn!("Failed to send connection info: {}", e);
                    false
                }
            }
        }
    }
);

impl VsockListenerDelegate {
    fn new(notifier: mpsc::Sender<ConnectionInfo>, job_id: Uuid) -> Retained<Self> {
        let ivars = VSockListenerState {
            connection_notifier: std::sync::Mutex::new(Some(notifier)),
            job_id,
        };

        unsafe { msg_send![super(Self::alloc().set_ivars(ivars)), init] }
    }
}

/// macOS implementation of VM provider
pub struct MacosVm {
    /// The VM configuration
    config: VM,
    /// Resource guard for automatic resource release (kept alive for RAII cleanup)
    _resource_guard: Option<ResourceGuard>,
    /// The VM identifier
    id: String,
    /// The runtime directory for VM-related files (as TempDir for auto-cleanup)
    _run_dir_temp: tempfile::TempDir,
    /// Path to the runtime directory (cached for trait compliance)
    run_dir: PathBuf,
    /// The macOS VM instance
    vm: Arc<QueueBound<Retained<VZVirtualMachine>>>,
    // The MAC address of the VM's network interface
    // Use `arp -a` to the IP address (e.g. 192.168.65.0/24)
    mac_address: String,
    /// Job configuration if available
    job_config: Option<JobConfig>,
    /// Shared state for job result from vsock
    job_result: Arc<Mutex<Option<bool>>>,
    #[allow(dead_code)]
    /// The delegate for vsock connection callbacks. Keep alive to retain the listener.
    socket_delegate: Option<Arc<Retained<VsockListenerDelegate>>>,
    vsock_server_handle: Option<tokio::task::JoinHandle<()>>,
}

unsafe impl Send for MacosVm {}
unsafe impl Sync for MacosVm {}

#[async_trait::async_trait]
impl VmTrait for MacosVm {
    /// Create a new VM with the given configuration
    async fn new(
        vm_config: VM,
        id: String,
        resource_manager: Arc<ResourceManager>,
    ) -> Result<Self> {
        // Create a temporary directory for this VM (will be auto-cleaned on drop)
        let run_dir_temp =
            tempfile::tempdir().wrap_err("Failed to create temporary runtime directory")?;
        let run_dir = run_dir_temp.path().to_path_buf();

        // Allocate resources for the VM
        let job_id = uuid::Uuid::now_v7(); // Generate a unique job ID for this VM
        let resource_guard = resource_manager
            .allocate_resources(job_id, vm_config.clone())
            .await
            .map_err(|e| eyre::eyre!("Failed to allocate resources for VM {}: {:?}", id, e))?;

        let resources_dir = PathBuf::from(
            std::env::var("RESOURCES_DIR").expect("RESOURCES_DIR environment variable must be set"),
        );

        info!(
            "Creating macOS VM {} with {} CPUs and {}MB memory",
            id, vm_config.cpu_count, vm_config.memory_size_mb
        );

        // Read the VM image's configuration.
        // This contains information about the VM's hardware configuration.
        let config_path = resources_dir.join("config.json");
        let image_config = VmImageConfig::from_file(&config_path)?;

        let hardware_model = unsafe {
            let data = NSData::initWithBase64EncodedString_options(
                NSData::alloc(),
                &NSString::from_str(&image_config.hardware_model),
                NSDataBase64DecodingOptions(0),
            )
            .unwrap();
            VZMacHardwareModel::initWithDataRepresentation(VZMacHardwareModel::alloc(), &data)
        }
        .expect("Failed to load hardware model");

        let aux_storage_path = {
            let path = NSString::from_str(&resources_dir.join("nvram.bin").to_string_lossy());
            unsafe { NSURL::initFileURLWithPath(NSURL::alloc(), &path) }
        };

        let machine_identifier = unsafe {
            let data = NSData::initWithBase64EncodedString_options(
                NSData::alloc(),
                &NSString::from_str(&image_config.ecid),
                NSDataBase64DecodingOptions(0),
            )
            .unwrap();
            VZMacMachineIdentifier::initWithDataRepresentation(
                VZMacMachineIdentifier::alloc(),
                &data,
            )
        }
        .expect("Failed to load machine identifier");

        let config = unsafe {
            let config = VZVirtualMachineConfiguration::new();

            let platform = {
                let platform = VZMacPlatformConfiguration::new();
                platform.setAuxiliaryStorage(Some(&VZMacAuxiliaryStorage::initWithURL(
                    VZMacAuxiliaryStorage::alloc(),
                    &aux_storage_path,
                )));
                platform.setHardwareModel(&hardware_model);
                platform.setMachineIdentifier(&machine_identifier);
                Retained::into_super(platform)
            };

            config.setPlatform(&platform);
            config.setBootLoader(Some(&VZMacOSBootLoader::new()));
            config.setCPUCount(vm_config.cpu_count);
            config.setMemorySize(vm_config.memory_size_mb * 1024 * 1024);

            // initForScreen_sizeInPoints can read the pixel density from the screen, but
            // requires fetching NSScreen from the main thread.
            let display = {
                let graphics_device = VZMacGraphicsDeviceConfiguration::new();
                graphics_device.setDisplays(&NSArray::from_retained_slice(&[
                        VZMacGraphicsDisplayConfiguration::initWithWidthInPixels_heightInPixels_pixelsPerInch(
                            VZMacGraphicsDisplayConfiguration::alloc(),
                            1920, 1080, 80
                        ),
                    ]));
                Retained::into_super(graphics_device)
            };
            config.setGraphicsDevices(&NSArray::from_retained_slice(&[display]));

            config.setKeyboards(&NSArray::from_retained_slice(&[Retained::into_super(
                VZMacKeyboardConfiguration::new(),
            )]));
            config.setPointingDevices(&NSArray::from_retained_slice(&[Retained::into_super(
                VZMacTrackpadConfiguration::new(),
            )]));

            let disk_path = resources_dir.join("disk.img");
            let disk_path_nsstr = NSString::from_str(&disk_path.to_string_lossy());
            let disk_path_url = NSURL::initFileURLWithPath(NSURL::alloc(), &disk_path_nsstr);
            let disk = {
                let attachment = VZDiskImageStorageDeviceAttachment::initWithURL_readOnly_cachingMode_synchronizationMode_error(
                        VZDiskImageStorageDeviceAttachment::alloc(),
                        &disk_path_url,
                        false,
                        VZDiskImageCachingMode::Automatic,
                        VZDiskImageSynchronizationMode::Fsync,
                    )
                    .unwrap_or_else(|err| panic!("failed to create disk {}, err={}", disk_path.to_string_lossy(), err.localizedDescription()));

                let disk = VZVirtioBlockDeviceConfiguration::initWithAttachment(
                    VZVirtioBlockDeviceConfiguration::alloc(),
                    &attachment,
                );
                Retained::into_super(disk)
            };

            config.setStorageDevices(&NSArray::from_retained_slice(&[disk]));

            let network = {
                let network = VZVirtioNetworkDeviceConfiguration::new();
                network.setAttachment(Some(&VZNATNetworkDeviceAttachment::new()));
                let mac_address = VZMACAddress::randomLocallyAdministeredAddress();
                network.setMACAddress(&mac_address);
                Retained::into_super(network)
            };
            config.setNetworkDevices(&NSArray::from_retained_slice(&[network]));

            config.setMemoryBalloonDevices(&NSArray::from_retained_slice(&[Retained::into_super(
                VZVirtioTraditionalMemoryBalloonDeviceConfiguration::new(),
            )]));
            config.setEntropyDevices(&NSArray::from_retained_slice(&[Retained::into_super(
                VZVirtioEntropyDeviceConfiguration::new(),
            )]));

            // Add a vsock device to the VM configuration
            config.setSocketDevices(&NSArray::from_retained_slice(&[Retained::into_super(
                VZVirtioSocketDeviceConfiguration::new(),
            )]));

            config
        };

        // Validate the VM configuration
        unsafe {
            config.validateWithError().unwrap_or_else(|err| {
                panic!(
                    "Failed to validate virtual machine configuration, err={}",
                    err.localizedDescription()
                )
            });
        }

        // Create VM but don't start it yet
        let dispatch_queue = DispatchQueue::new(&id, DispatchQueueAttr::SERIAL);

        let vm = unsafe {
            VZVirtualMachine::initWithConfiguration_queue(
                VZVirtualMachine::alloc(),
                &config,
                &dispatch_queue,
            )
        };

        // TODO: add a delegate to detect shutdown requests and errors.
        // See https://docs.rs/objc2-virtualization/latest/objc2_virtualization/struct.VZVirtualMachine.html#method.setDelegate

        debug!(
            "MacOS VM {} successfully created with {} vCPUs",
            id, vm_config.cpu_count
        );

        let vm = Arc::new(QueueBound::new(vm, dispatch_queue));

        let mac_address = unsafe {
            config
                .networkDevices()
                .objectAtIndex(0)
                .downcast::<VZVirtioNetworkDeviceConfiguration>()
                .unwrap()
                .MACAddress()
                .string()
                .to_string()
        };

        Ok(Self {
            config: vm_config,
            _resource_guard: Some(resource_guard),
            id,
            _run_dir_temp: run_dir_temp,
            run_dir,
            vm,
            mac_address,
            job_config: None,
            job_result: Arc::new(Mutex::new(None)),
            socket_delegate: None,
            vsock_server_handle: None,
        })
    }

    async fn start(&mut self) -> Result<()> {
        info!("Starting MacOS VM {}. MAC: {}", self.id, self.mac_address);

        debug!("About to call vm.run_sync for VM start");
        self.vm.run_sync(|vm| {
            debug!("Inside run_sync, creating completion handler");
            let completion_handler = StackBlock::new(move |err: *mut NSError| {
                if !err.is_null() {
                    error!("Failed to start VM, err={}", unsafe {
                        (*err).localizedDescription()
                    });
                } else {
                    info!("VM started successfully");
                }
            });
            debug!("Calling startWithCompletionHandler");
            unsafe { vm.startWithCompletionHandler(&completion_handler) };
            debug!("startWithCompletionHandler call completed");
        });
        info!("VM start process completed for {}", self.id);

        Ok(())
    }

    /// Wait for the VM to finish by periodically polling its state
    async fn wait(&mut self) -> Result<crate::vm::VmExitStatus> {
        info!("MacOS VM {} wait called", self.id);

        // Poll the VM state every 500ms
        let poll_interval = std::time::Duration::from_millis(500);

        loop {
            // Get the current VM state
            let state = self.vm.run_sync(|vm| unsafe { vm.state() });

            match state {
                // VM is running, continue polling
                VZVirtualMachineState::Running => {
                    tokio::time::sleep(poll_interval).await;
                }

                // VM has stopped, either normally or due to error
                VZVirtualMachineState::Stopped => {
                    info!("VM {} has stopped normally", self.id);
                    return Ok(crate::vm::VmExitStatus::Success);
                }

                // VM is in error state
                VZVirtualMachineState::Error => {
                    error!("VM {} encountered an error and stopped", self.id);
                    return Ok(crate::vm::VmExitStatus::Failure);
                }

                // Other states that might occur during shutdown
                VZVirtualMachineState::Stopping => {
                    info!("VM {} is stopping, waiting for completion", self.id);
                    tokio::time::sleep(poll_interval).await;
                }

                // Other transitional or unexpected states
                state => {
                    debug!("VM {} is in state {:?}, continuing to poll", self.id, state);
                    tokio::time::sleep(poll_interval).await;
                }
            }
        }
    }

    // TODO: stop with timeout
    async fn shutdown(&mut self) -> Result<()> {
        info!("MacOS VM {} shutdown called", self.id);

        self.vm.run_sync(|vm| {
            if unsafe { vm.canRequestStop() } {
                match unsafe { vm.requestStopWithError() } {
                    Ok(_) => {
                        info!("VM {} stop request successful", self.id);
                    }
                    Err(err) => {
                        error!("Failed to stop VM: {}", err.localizedDescription());
                    }
                }
            }
        });

        Ok(())
    }

    fn config(&self) -> &VM {
        &self.config
    }

    fn id(&self) -> &str {
        &self.id
    }

    fn run_dir(&self) -> &PathBuf {
        &self.run_dir
    }

    /// Set job configuration and start vsock server to send it to the guest
    ///
    /// MacOS does not allow using vsock directly.
    /// We must go through the Virtualization framework to get a connection.
    async fn set_job_config(
        &mut self,
        job_config: JobConfig,
        log_sender: tokio::sync::mpsc::Sender<String>,
    ) -> Result<()> {
        // Store job config
        self.job_config = Some(job_config.clone());

        // Create an mpsc channel to handle multiple connections
        let (tx, mut rx) = mpsc::channel::<ConnectionInfo>(10);

        info!("Setting up vsock listener for job {}", job_config.id);

        // We need to set up the listener on the VM's vsock device
        let port = crate::protocol::CONFIG_VSOCK_PORT;
        let job_id = job_config.id;

        // We need to set up the listener on the VM's dispatch queue
        // We'll use a channel to get the delegate back after it's created on the queue
        let (delegate_tx, delegate_rx) =
            std::sync::mpsc::channel::<Retained<VsockListenerDelegate>>();

        // Set up everything in run_sync
        self.vm.run_sync(move |vm| {
            // Check if we have socket devices
            let socket_devices = unsafe { vm.socketDevices() };

            if socket_devices.count() == 0 {
                panic!("No socket devices found in VM configuration");
            }

            // Create the delegate on this queue
            let delegate = VsockListenerDelegate::new(tx, job_id);

            // Send the delegate back through the channel so we can store it
            let _ = delegate_tx.send(delegate.clone());

            let listener = unsafe { VZVirtioSocketListener::new() };
            unsafe { listener.setDelegate(Some(&ProtocolObject::from_retained(delegate))) };

            // Get the vsock device and set the listener
            let socket_device = socket_devices
                .objectAtIndex(0)
                .downcast::<VZVirtioSocketDevice>()
                .unwrap();

            unsafe {
                socket_device.setSocketListener_forPort(&listener, port);
            }

            info!("Socket listener set for port {} successfully", port);
        });

        self.socket_delegate = Some(Arc::new(
            delegate_rx
                .recv()
                .expect("Failed to receive delegate from dispatch queue"),
        ));
        debug!("Received delegate from dispatch queue, delegate retained by socket device");

        // Always spawn a thread that will wait for the connection notification
        let job_id = job_config.id;
        let job_result = self.job_result.clone();

        // Create a notification channel to signal when the server should shut down
        let shutdown_notify = Arc::new(Notify::new());

        // Start a tokio task to wait for the connection information
        let handle = tokio::spawn(async move {
            info!("Starting connection waiting task for job {}", job_id);

            loop {
                let shutdown_notify_clone = shutdown_notify.clone();

                tokio::select! {
                    accept_result = rx.recv() => {
                        match accept_result {
                            Some(conn_info) => {
                                info!(
                                    "Connection established for job {}! Source port: {} Destination port: {}",
                                    job_id, conn_info.source_port, conn_info.destination_port
                                );

                                // First connection: handle config exchange
                                let std_stream = conn_info.stream;
                                let job_config = job_config.clone();
                                let job_result = job_result.clone();
                                let shutdown_notify = shutdown_notify.clone();
                                let log_sender = log_sender.clone();

                                info!("Starting config server communication for job {}", job_id);

                                // Convert std UnixStream to tokio UnixStream inside the async context
                                let mut tokio_stream = match std_stream.set_nonblocking(true) {
                                    Ok(_) => match UnixStream::from_std(std_stream) {
                                        Ok(s) => s,
                                        Err(e) => {
                                            error!("Failed to convert to tokio UnixStream: {}", e);
                                            return;
                                        }
                                    },
                                    Err(e) => {
                                        error!("Failed to set stream to non-blocking: {}", e);
                                        return;
                                    }
                                };

                                tokio::spawn(async move {
                                    if let Err(e) = vsock::handle_guest_connection(
                                        &mut tokio_stream,
                                        job_config,
                                        Some(job_result),
                                        shutdown_notify,
                                        log_sender,
                                    )
                                    .await
                                    {
                                        error!("Error handling guest connection: {:?}", e);
                                    }
                                });
                            }
                            None => error!("Failed to accept connection"),
                        }
                    }

                    // Wait for shutdown signal
                    _ = shutdown_notify_clone.notified() => {
                        info!("Vsock server shutting down after job completion");
                        break;
                    }
                }
            }

            info!("Connection handler task completed for job {}", job_id);
        });

        // Store the handle so we can abort it during shutdown
        self.vsock_server_handle = Some(handle);

        info!("Set up vsock listener for job {}", job_id);
        Ok(())
    }
}
